var co = require('co');
var path = require('path');
var fs = require('fs');
var util = require('util');
var hfc = require('fabric-client');
var Peer = require('fabric-client/lib/Peer.js');
var User = require('fabric-client/lib/User.js');
var crypto = require('crypto');

var log4js = require('log4js');
var logger = log4js.getLogger('Helper');
logger.level= 'DEBUG';

var tempdir ="/home/hzaucoi/js-mysql/fabric-client-kvs";
var client = new hfc();

var channel = client.newChannel('vegetableschannel');

var order = client.newOrderer('grpc://172.16.174.45:7050');
channel.addOrderer(order);

var peer = client.newPeer('grpc://172.16.174.45:7051'); //peer0.org1
channel.addPeer(peer);

var peer1 = client.newPeer('grpc://172.16.174.46:7051'); //per0.org2
channel.addPeer(peer1);

/* 
Call the query method of the chaincode and return the result of the transaction information.
The verifier uses this function to verify arbitrary/standard range proof 
using VerifyProofs_ArbitraryRange/VerifyProofs_StandardRange chaincode.
*/
var queryCc = function(chaincodeid,func,chaincode_args){

	return getOrgAdmin4Local().then( (user)=> {

		tx_id = client.newTransactionID();
		var request = {
			chaincodeId: chaincodeid,
			txId: tx_id,
			fcn: func,
			args:chaincode_args

		};
		
		return channel.queryByChaincode(request,peer1);
	},(err)=>{
		
		console.log('error',e);
		
	}).then( (sendtransresult) => {
		
		return sendtransresult;
		
	},(err)=>{
		
		console.log('error',e);
		
	});
}

/*
Call the invoke method of the chaincode to initiate a transaction and return the result of the transaction information.
The prover uses this function when generating arbitrary/standard range proof using GenProofs_ArbitraryRange/GenProofs_StandardRange chaincode.
*/
var sendTransaction = function(chaincodeid,func,chaincode_args){

	var tx_id = null;
   	return getOrgAdmin4Local().then( (user)=> {

        	tx_id = client.newTransactionID();
		var request = {
				chaincodeId: chaincodeid,
				fcn: func,
				args:chaincode_args,
				chainId: "vegetableschannel",
				txId: tx_id

		};
        	return channel.sendTransactionProposal(request);
	},(err)=>{

        	console.log('error',e);
	}).then( (chaincodeinvokeresult) => {

		var proposalResponses = chaincodeinvokeresult[0];
		var proposal = chaincodeinvokeresult[1];
		var header = chaincodeinvokeresult[2];
		var all_good = true;

		for (var i in proposalResponses){
			
			let one_good = false;
			if(proposalResponses && proposalResponses[0].response && proposalResponses[0].response.status === 200){
					one_good = true;
					console.info('transcation proposal was good');
			}else{
					console.info('transcation proposal was bad');
			}

			all_good = all_good & one_good;

		}
		
		if(all_good){
			console.info(util.format('Successfully :Status - %s,message - "%s",metadata - "%s",endorsement signature :%s',proposalResponses[0].response.status,
proposalResponses[0].response.message,proposalResponses[0].response.payload,proposalResponses[0].endorsement.signature));

			var request = {
					proposalResponses:proposalResponses,
					proposal:proposal,
					header:header
			};

			var transactionID = tx_id.getTransactionID();
			return channel.sendTransaction(request);
		}

	},(err)=>{
		console.log('error',e);
	}).then( (sendtransresult) => {
		
		return sendtransresult;
		
	},(err)=>{
		console.log('error',e);
	});
}

/*
According to the channel that peer joined, get the detailed information of the chaincode whose status is instantiatedresult.
Use this function to verify the chaincode version is modified or not.
*/
var getInstantiatedChaincodes = function() {

	return getOrgAdmin4Local().then( (user)=> {

		return channel.queryInstantiatedChaincodes(peer);

	},(err)=>{
		
		console.log('error',e);
		
	}).then( (instantiatedresult) => {
		
		return instantiatedresult;
		
	},(err)=>{
        console.log('error',e);
	});
}

/*
Perform related operations through the Fabric interface according to the certificate information generated by the cryptogen module
*/
function getOrgAdmin4Local() {

	var keyPath = "/root/aberic/crypto-config/peerOrganizations/vegetablesorg1.fssbc.com/users/Admin@vegetablesorg1.fssbc.com/msp/keystore" ;
	var keyPEM = Buffer.from(readAllFiles(keyPath)[0].toString());
	var certPath = "/root/aberic/crypto-config/peerOrganizations/vegetablesorg1.fssbc.com/users/Admin@vegetablesorg1.fssbc.com/msp/signcerts";
	var certPEM = readAllFiles(certPath)[0].toString();

	return hfc.newDefaultKeyValueStore({
		path:tempdir
	}).then((store) => {
		client.setStateStore(store);

		return client.createUser({
			username: 'Admin',
			mspid: 'VegetablesOrg1MSP',
			cryptoContent: {
				privateKeyPEM: keyPEM,
				signedCertPEM: certPEM
			}
		});
	});
};


function readAllFiles(dir) {
	
	var files = fs.readdirSync(dir);
	var certs = [];
	files.forEach((file_name) => {
		let file_path = path.join(dir, file_name);
		let data = fs.readFileSync(file_path);
		certs.push(data);
	});
	
	return certs;
}

exports.sendTransaction = sendTransaction;
exports.queryCc = queryCc;
exports.getInstantiatedChaincodes = getInstantiatedChaincodes;
